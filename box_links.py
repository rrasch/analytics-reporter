#!/usr/bin/env python3
"""
box_links.py — Upload files to Box via rclone and generate company-only
shared links. Includes remote existence checks and structured logging.

Generated by ChatGPT.

Requirements:
    - rclone must be installed and configured with a Box remote.
    - The Box remote must have permission to create shared links.
"""

import json
import logging
import subprocess
from pathlib import Path
from typing import Dict, List, Optional

LOG = logging.getLogger(__name__)


# ------------------------------------------------------------
# Internal rclone runner
# ------------------------------------------------------------
def _run_rclone(args: List[str]) -> str:
    """Run rclone with the given arguments and return stdout."""
    LOG.debug("Running rclone command: %s", " ".join(["rclone"] + args))

    try:
        result = subprocess.run(
            ["rclone"] + args,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            encoding="utf-8",
            check=True,
        )
        stdout = result.stdout.strip()
        LOG.debug("rclone stdout: %s", stdout)
        return stdout

    except subprocess.CalledProcessError as e:
        LOG.error(
            "rclone failed: %s\nstdout: %s\nstderr: %s",
            " ".join(e.cmd),
            e.stdout,
            e.stderr,
        )
        raise RuntimeError(
            f"rclone failed: {' '.join(e.cmd)}\n"
            f"stdout: {e.stdout}\n"
            f"stderr: {e.stderr}"
        )


# ------------------------------------------------------------
# Remote existence check
# ------------------------------------------------------------
def remote_exists_lsf(remote_path: str) -> bool:
    """
    Return True if a file exists on the remote.

    This works by listing files in the parent folder via rclone lsf.
    """
    LOG.debug("Checking if remote file exists: %s", remote_path)

    # Split into parent directory + filename
    try:
        parent, name = remote_path.rsplit("/", 1)
    except ValueError:
        LOG.error("Remote path must contain a folder: %s", remote_path)
        return False

    try:
        out = _run_rclone(["lsf", parent, "--files-only"])
    except RuntimeError:
        LOG.info("Remote parent folder not found: %s", parent)
        return False

    files = {line.strip() for line in out.splitlines() if line.strip()}

    exists = name in files
    LOG.debug("Exists? %s → %s", name, exists)

    return exists


def remote_exists(remote_path: str) -> bool:
    """
    Check if a single file exists on the rclone remote using:
        rclone lsjson --stat remote:file

    rclone returns a *dict* for a single file.
    Returns True if the file exists, False otherwise.
    """
    LOG.debug("Checking remote file existence (fast): %s", remote_path)

    try:
        out = _run_rclone(["lsjson", "--stat", remote_path])
    except Exception as e:
        LOG.debug("rclone reports file does not exist: %s", e)
        return False

    # Validate JSON
    try:
        data = json.loads(out)
    except Exception as e:
        LOG.warning(
            "lsjson returned non-JSON output for %s: %s", remote_path, e
        )
        return False

    # Valid JSON → must be a dict for a single file
    if isinstance(data, dict) and data:
        LOG.debug("File exists: %s", remote_path)
        return True

    LOG.debug(
        "File does not exist (empty dict or unexpected JSON): %s", remote_path
    )
    return False


# ------------------------------------------------------------
# Upload
# ------------------------------------------------------------
def upload_to_box(local_path: str, remote_path: str) -> None:
    """Upload a file to the remote using rclone copyto."""
    LOG.info("Uploading '%s' to '%s'", local_path, remote_path)

    _run_rclone(["copyto", local_path, remote_path])
    LOG.info("Upload complete: %s", remote_path)


# ------------------------------------------------------------
# Link generation
# ------------------------------------------------------------
def get_box_link(remote_file: str) -> str:
    """Return a company-only shared link for the given remote file."""
    LOG.info("Generating shared link for %s", remote_file)

    output = _run_rclone(["link", remote_file])

    LOG.info("Generated link: %s", output)
    return output.strip()


def get_box_links_in_folder(folder: str) -> Dict[str, str]:
    """Generate company-only links for all files in a folder."""
    LOG.info("Generating links for all files in folder: %s", folder)

    ls_output = _run_rclone(["lsjson", "--files-only", folder])
    files = json.loads(ls_output)
    out = {}

    for entry in files:
        filename = entry["Path"]
        remote_file = f"{folder}/{filename}"
        LOG.debug("Processing %s", remote_file)

        link = get_box_link(remote_file)
        out[filename] = link

    LOG.info("Generated %d links", len(out))
    return out


# ------------------------------------------------------------
# Upload + link convenience helper
# ------------------------------------------------------------
def upload_and_get_link(
    local_path: str,
    remote_folder: str,
    remote_filename: Optional[str] = None,
    overwrite: bool = False,
) -> str:
    """
    Upload a file to Box (unless already present) and return a
    company-only shared link.

    Args:
        local_path (str): Path to local file.
        remote_folder (str): rclone folder path, e.g. "box:team/docs".
        remote_filename (str): Optional name on Box (defaults to basename).
        overwrite (bool): Upload even if remote exists?
    """
    local = Path(local_path)
    name = remote_filename or local.name
    remote_path = f"{remote_folder}/{name}"

    LOG.info(
        "upload_and_get_link: local=%s remote=%s overwrite=%s",
        local_path,
        remote_path,
        overwrite,
    )

    if remote_exists(remote_path):
        if not overwrite:
            LOG.info("Remote file exists; skipping upload: %s", remote_path)
            return get_box_link(remote_path)

        LOG.warning("Remote file exists; overwriting: %s", remote_path)

    upload_to_box(local_path, remote_path)

    return get_box_link(remote_path)
